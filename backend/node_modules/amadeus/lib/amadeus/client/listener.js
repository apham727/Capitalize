'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _response = require('./response');

var _response2 = _interopRequireDefault(_response);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Listen to changes in the HTTP request and build Response/ResponseError
 * objects accordingly.
 *
 * @param {Request} request the request object used to make the call
 * @param {EventEmitter} emitter a Node event emitter
 * @param {Client} client the client instance to log results to
 * @protected
 */
var Listener = function () {
  function Listener(request, emitter, client) {
    _classCallCheck(this, Listener);

    this.request = request;
    this.emitter = emitter;
    this.client = client;
  }

  // PROTECTED


  /**
   * Listens to various events on the http_response object, listening for data,
   * connections closing for bad reasons, and the end of the response.
   *
   * Used by the Client when making an API call.
   *
   * @param  {Object} http_response a Node http response object
   * @protected
   */


  _createClass(Listener, [{
    key: 'onResponse',
    value: function onResponse(http_response) {
      var response = new _response2.default(http_response, this.request);

      http_response.on('data', response.addChunk.bind(response));
      http_response.on('end', this.onEnd(response).bind(this));
      http_response.on('close', this.onNetworkError(response).bind(this));
      http_response.on('error', this.onNetworkError(response).bind(this));
    }

    /**
     * Listens to a network error when making an API call.
     *
     * Used by the Client when making an API call.
     *
     * @param  {Object} http_response a Node http response object
     * @protected
     */

  }, {
    key: 'onError',
    value: function onError(http_response) {
      var response = new _response2.default(http_response, this.request);
      this.onNetworkError(response)();
    }

    // PRIVATE


    /**
     * When the connection ends, check if the response can be parsed or not and
     * act accordingly.
     *
     * @param  {Response} response
     */

  }, {
    key: 'onEnd',
    value: function onEnd(response) {
      var _this = this;

      return function () {
        response.parse();
        if (response.success()) {
          _this.onSuccess(response);
        } else {
          _this.onFail(response);
        }
      };
    }

    /**
     * When the response was successful, resolve the promise and return the
     * response object
     *
     * @param  {Response} response
     */

  }, {
    key: 'onSuccess',
    value: function onSuccess(response) {
      this.log(response);
      this.emitter.emit('resolve', response);
    }

    /**
     * When the connection was not successful, determine the reason and resolve
     * the promise accordingly.
     *
     * @param  {Response} response
     */

  }, {
    key: 'onFail',
    value: function onFail(response) {
      var Error = this.errorFor(response);
      var error = new Error(response);
      this.log(response, error);
      this.emitter.emit('reject', error);
    }

    /**
     * Find the right error for the given response.
     *
     * @param {Response} reponse
     * @returns {ResponseError}
     */

  }, {
    key: 'errorFor',
    value: function errorFor(_ref) {
      var statusCode = _ref.statusCode,
          parsed = _ref.parsed;

      var error = null;
      if (statusCode >= 500) {
        error = _errors.ServerError;
      } else if (statusCode == 401) {
        error = _errors.AuthenticationError;
      } else if (statusCode == 404) {
        error = _errors.NotFoundError;
      } else if (statusCode >= 400) {
        error = _errors.ClientError;
      } else if (!parsed) {
        error = _errors.ParserError;
      } else {
        error = _errors.UnknownError;
      }
      return error;
    }

    /**
     * When the connection ran into a network error, reject the promise with a
     * NetworkError.
     *
     * @param  {Response} response
     */

  }, {
    key: 'onNetworkError',
    value: function onNetworkError(response) {
      var _this2 = this;

      return function () {
        response.parse();
        var error = new _errors.NetworkError(response);
        _this2.log(response, error);
        _this2.emitter.emit('reject', error);
      };
    }

    /**
     * Logs the response, when in debug mode
     *
     * @param  {Response} response the response object to log
     * @private
     */

  }, {
    key: 'log',
    value: function log(response, error) {
      if (this.client.debug()) {
        /* istanbul ignore next */
        this.client.logger.log(_util2.default.inspect(response, false, null));
      }
      if (!this.client.debug() && this.client.warn() && error) {
        /* istanbul ignore next */
        this.client.logger.log('Amadeus', error.code, error.description);
      }
    }
  }]);

  return Listener;
}();

exports.default = Listener;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hbWFkZXVzL2NsaWVudC9saXN0ZW5lci5qcyJdLCJuYW1lcyI6WyJMaXN0ZW5lciIsInJlcXVlc3QiLCJlbWl0dGVyIiwiY2xpZW50IiwiaHR0cF9yZXNwb25zZSIsInJlc3BvbnNlIiwiUmVzcG9uc2UiLCJvbiIsImFkZENodW5rIiwiYmluZCIsIm9uRW5kIiwib25OZXR3b3JrRXJyb3IiLCJwYXJzZSIsInN1Y2Nlc3MiLCJvblN1Y2Nlc3MiLCJvbkZhaWwiLCJsb2ciLCJlbWl0IiwiRXJyb3IiLCJlcnJvckZvciIsImVycm9yIiwic3RhdHVzQ29kZSIsInBhcnNlZCIsIlNlcnZlckVycm9yIiwiQXV0aGVudGljYXRpb25FcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJDbGllbnRFcnJvciIsIlBhcnNlckVycm9yIiwiVW5rbm93bkVycm9yIiwiTmV0d29ya0Vycm9yIiwiZGVidWciLCJsb2dnZXIiLCJ1dGlsIiwiaW5zcGVjdCIsIndhcm4iLCJjb2RlIiwiZGVzY3JpcHRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFXQTs7Ozs7Ozs7O0lBU01BLFE7QUFDSixvQkFBWUMsT0FBWixFQUFxQkMsT0FBckIsRUFBOEJDLE1BQTlCLEVBQXNDO0FBQUE7O0FBQ3BDLFNBQUtGLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLE1BQUwsR0FBZUEsTUFBZjtBQUNEOztBQUVEOzs7QUFHQTs7Ozs7Ozs7Ozs7OzsrQkFTV0MsYSxFQUFlO0FBQ3hCLFVBQUlDLFdBQVcsSUFBSUMsa0JBQUosQ0FBYUYsYUFBYixFQUE0QixLQUFLSCxPQUFqQyxDQUFmOztBQUVBRyxvQkFBY0csRUFBZCxDQUFpQixNQUFqQixFQUEwQkYsU0FBU0csUUFBVCxDQUFrQkMsSUFBbEIsQ0FBdUJKLFFBQXZCLENBQTFCO0FBQ0FELG9CQUFjRyxFQUFkLENBQWlCLEtBQWpCLEVB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WixFQUFELElBQXdCLEtBQUszQixNQUFMLENBQVkrQixJQUFaLEVBQXhCLElBQThDZCxLQUFsRCxFQUF5RDtBQUN2RDtBQUNBLGFBQUtqQixNQUFMLENBQVk0QixNQUFaLENBQW1CZixHQUFuQixDQUF1QixTQUF2QixFQUFrQ0ksTUFBTWUsSUFBeEMsRUFBOENmLE1BQU1nQixXQUFwRDtBQUNEO0FBQ0Y7Ozs7OztrQkFHWXBDLFEiLCJmaWxlIjoibGlzdGVuZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVzcG9uc2UgZnJvbSAnLi9yZXNwb25zZSc7XG5pbXBvcnQgdXRpbCAgICAgZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7XG4gIFNlcnZlckVycm9yLFxuICBOb3RGb3VuZEVycm9yLFxuICBDbGllbnRFcnJvcixcbiAgUGFyc2VyRXJyb3IsXG4gIFVua25vd25FcnJvcixcbiAgTmV0d29ya0Vycm9yLFxuICBBdXRoZW50aWNhdGlvbkVycm9yXG59IGZyb20gJy4vZXJyb3JzJztcblxuXG4vKipcbiAqIExpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSBIVFRQIHJlcXVlc3QgYW5kIGJ1aWxkIFJlc3BvbnNlL1Jlc3BvbnNlRXJyb3JcbiAqIG9iamVjdHMgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0IHRoZSByZXF1ZXN0IG9iamVjdCB1c2VkIHRvIG1ha2UgdGhlIGNhbGxcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIGEgTm9kZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IHRoZSBjbGllbnQgaW5zdGFuY2UgdG8gbG9nIHJlc3VsdHMgdG9cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuY2xhc3MgTGlzdGVuZXIge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0LCBlbWl0dGVyLCBjbGllbnQpIHtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5jbGllbnQgID0gY2xpZW50O1xuICB9XG5cbiAgLy8gUFJPVEVDVEVEXG5cblxuICAvKipcbiAgICogTGlzdGVucyB0byB2YXJpb3VzIGV2ZW50cyBvbiB0aGUgaHR0cF9yZXNwb25zZSBvYmplY3QsIGxpc3RlbmluZyBmb3IgZGF0YSxcbiAgICogY29ubmVjdGlvbnMgY2xvc2luZyBmb3IgYmFkIHJlYXNvbnMsIGFuZCB0aGUgZW5kIG9mIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogVXNlZCBieSB0aGUgQ2xpZW50IHdoZW4gbWFraW5nIGFuIEFQSSBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGh0dHBfcmVzcG9uc2UgYSBOb2RlIGh0dHAgcmVzcG9uc2Ugb2JqZWN0XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG9uUmVzcG9uc2UoaHR0cF9yZXNwb25zZSkge1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShodHRwX3Jlc3BvbnNlLCB0aGlzLnJlcXVlc3QpO1xuXG4gICAgaHR0cF9yZXNwb25zZS5vbignZGF0YScsICByZXNwb25zZS5hZGRDaHVuay5iaW5kKHJlc3BvbnNlKSk7XG4gICAgaHR0cF9yZXNwb25zZS5vbignZW5kJywgICB0aGlzLm9uRW5kKHJlc3BvbnNlKS5iaW5kKHRoaXMpKTtcbiAgICBodHRwX3Jlc3BvbnNlLm9uKCdjbG9zZScsIHRoaXMub25OZXR3b3JrRXJyb3IocmVzcG9uc2UpLmJpbmQodGhpcykpO1xuICAgIGh0dHBfcmVzcG9uc2Uub24oJ2Vycm9yJywgdGhpcy5vbk5ldHdvcmtFcnJvcihyZXNwb25zZSkuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVucyB0byBhIG5ldHdvcmsgZXJyb3Igd2hlbiBtYWtpbmcgYW4gQVBJIGNhbGwuXG4gICAqXG4gICAqIFVzZWQgYnkgdGhlIENsaWVudCB3aGVuIG1ha2luZyBhbiBBUEkgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBodHRwX3Jlc3BvbnNlIGEgTm9kZSBodHRwIHJlc3BvbnNlIG9iamVjdFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG4gIG9uRXJyb3IoaHR0cF9yZXNwb25zZSkge1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShodHRwX3Jlc3BvbnNlLCB0aGlzLnJlcXVlc3QpO1xuICAgIHRoaXMub25OZXR3b3JrRXJyb3IocmVzcG9uc2UpKCk7XG4gIH1cblxuICAvLyBQUklWQVRFXG5cblxuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiBlbmRzLCBjaGVjayBpZiB0aGUgcmVzcG9uc2UgY2FuIGJlIHBhcnNlZCBvciBub3QgYW5kXG4gICAqIGFjdCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtICB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBvbkVuZChyZXNwb25zZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNwb25zZS5wYXJzZSgpO1xuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MoKSkgeyB0aGlzLm9uU3VjY2VzcyhyZXNwb25zZSk7IH1cbiAgICAgIGVsc2UgeyB0aGlzLm9uRmFpbChyZXNwb25zZSk7ICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bCwgcmVzb2x2ZSB0aGUgcHJvbWlzZSBhbmQgcmV0dXJuIHRoZVxuICAgKiByZXNwb25zZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtICB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBvblN1Y2Nlc3MocmVzcG9uc2UpIHtcbiAgICB0aGlzLmxvZyhyZXNwb25zZSk7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoJ3Jlc29sdmUnLCByZXNwb25zZSk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB3YXMgbm90IHN1Y2Nlc3NmdWwsIGRldGVybWluZSB0aGUgcmVhc29uIGFuZCByZXNvbHZlXG4gICAqIHRoZSBwcm9taXNlIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIG9uRmFpbChyZXNwb25zZSkge1xuICAgIGxldCBFcnJvciA9IHRoaXMuZXJyb3JGb3IocmVzcG9uc2UpO1xuICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZSk7XG4gICAgdGhpcy5sb2cocmVzcG9uc2UsIGVycm9yKTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdCgncmVqZWN0JywgZXJyb3IpO1xuICB9XG5cblxuICAvKipcbiAgICogRmluZCB0aGUgcmlnaHQgZXJyb3IgZm9yIHRoZSBnaXZlbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVwb25zZVxuICAgKiBAcmV0dXJucyB7UmVzcG9uc2VFcnJvcn1cbiAgICovXG4gIGVycm9yRm9yKHtzdGF0dXNDb2RlLCBwYXJzZWR9KSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBpZiAoc3RhdHVzQ29kZSA+PSA1MDApIHsgZXJyb3IgPSBTZXJ2ZXJFcnJvcjsgfVxuICAgIGVsc2UgaWYgKHN0YXR1c0NvZGUgPT0gNDAxKSB7IGVycm9yID0gQXV0aGVudGljYXRpb25FcnJvcjsgfVxuICAgIGVsc2UgaWYgKHN0YXR1c0NvZGUgPT0gNDA0KSB7IGVycm9yID0gTm90Rm91bmRFcnJvcjsgfVxuICAgIGVsc2UgaWYgKHN0YXR1c0NvZGUgPj0gNDAwKSB7IGVycm9yID0gQ2xpZW50RXJyb3I7IH1cbiAgICBlbHNlIGlmICghcGFyc2VkKSB7IGVycm9yID0gUGFyc2VyRXJyb3I7IH1cbiAgICBlbHNlIHsgZXJyb3IgPSBVbmtub3duRXJyb3I7IH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiByYW4gaW50byBhIG5ldHdvcmsgZXJyb3IsIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIGFcbiAgICogTmV0d29ya0Vycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIG9uTmV0d29ya0Vycm9yKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc3BvbnNlLnBhcnNlKCk7XG4gICAgICBsZXQgZXJyb3IgPSBuZXcgTmV0d29ya0Vycm9yKHJlc3BvbnNlKTtcbiAgICAgIHRoaXMubG9nKHJlc3BvbnNlLCBlcnJvcik7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdCgncmVqZWN0JywgZXJyb3IpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgcmVzcG9uc2UsIHdoZW4gaW4gZGVidWcgbW9kZVxuICAgKlxuICAgKiBAcGFyYW0gIHtSZXNwb25zZX0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIG9iamVjdCB0byBsb2dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxvZyhyZXNwb25zZSwgZXJyb3IpIHtcbiAgICBpZiAodGhpcy5jbGllbnQuZGVidWcoKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5sb2codXRpbC5pbnNwZWN0KHJlc3BvbnNlLCBmYWxzZSwgbnVsbCkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xpZW50LmRlYnVnKCkgJiYgdGhpcy5jbGllbnQud2FybigpICYmIGVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmxvZygnQW1hZGV1cycsIGVycm9yLmNvZGUsIGVycm9yLmRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlzdGVuZXI7XG4iXX0=