'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _client = require('./amadeus/client');

var _client2 = _interopRequireDefault(_client);

var _pagination = require('./amadeus/client/pagination');

var _pagination2 = _interopRequireDefault(_pagination);

var _reference_data = require('./amadeus/namespaces/reference_data');

var _reference_data2 = _interopRequireDefault(_reference_data);

var _shopping = require('./amadeus/namespaces/shopping');

var _shopping2 = _interopRequireDefault(_shopping);

var _travel = require('./amadeus/namespaces/travel');

var _travel2 = _interopRequireDefault(_travel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The Amadeus client library for accessing the travel APIs.
 *
 * Initialize using your credentials:
 *
 * ```js
 * var Amadeus = require('amadeus');
 * var amadeus = new Amadeus({
 *     clientId:    'YOUR_CLIENT_ID',
 *     clientSecret: 'YOUR_CLIENT_SECRET'
 * });
 * ```
 *
 * Alternatively, initialize the library using
 * the environment variables `AMADEUS_CLIENT_ID`
 * and `AMADEUS_CLIENT_SECRET`
 *
 * ```js
 * var amadeus = new Amadeus();
 * ```
 *
 * @param {Object} params
 * @param {string} params.clientId the API key used to authenticate the API
 * @param {string} params.clientSecret the API secret used to authenticate
 *  the API
 * @param {Object} [params.logger=console] a `console`-compatible logger that
 *  accepts `log`, `error` and `debug` calls.
 * @param {string} [params.logLevel='warn'] the log level for the client,
 *  available options are `debug`, `warn`, and `silent`
 * @param {string} [params.hostname='production'] the name of the server API
 *  calls are made to (`production` or `test`)
 * @param {string} [params.host] the full domain or IP for a server to make the
 *  API clal to. Only use this if you don't want to use the provided servers
 * @param {boolean} [params.ssl=true] wether to use SSL for this API call
 * @param {number} [params.port=443] the port to make the API call to
 * @param {string} [params.customAppId=null] a custom App ID to be passed in
 * the User Agent to the server.
 * @param {string} [params.customAppVersion=null] a custom App Version number to
 * be passed in the User Agent to the server.
 * @param {Object} [params.http=https] an optional Node/HTTP(S)-compatible client
 *  that accepts a 'request()' call with an array of options.
 *
 * @property {Client} client The client for making authenticated HTTP calls
 * @property {number} version The version of this API client
 */
var Amadeus = function () {
  function Amadeus() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Amadeus);

    this.client = new _client2.default(params);
    this.version = this.client.version;

    this.referenceData = new _reference_data2.default(this.client);
    this.shopping = new _shopping2.default(this.client);
    this.travel = new _travel2.default(this.client);
    this.pagination = new _pagination2.default(this.client);
  }

  /**
   * The previous page for the given response. Resolves to null if the page
   * could not be found.
   *
   * ```js
   * amadeus.referenceData.locations.get({
   *   keyword: 'LON',
   *   subType: 'AIRPORT,CITY',
   *   page: { offset: 2 }
   * }).then(function(response){
   *   console.log(response);
   *   return amadeus.previous(response);
   * }).then(function(previousPage){
   *   console.log(previousPage);
   * });
   * ```
   *
   * @param response the previous response for an API call
   * @return {Promise.<Response,ResponseError>} a Bluebird Promise
   */


  _createClass(Amadeus, [{
    key: 'previous',
    value: function previous(response) {
      return this.pagination.page('previous', response);
    }

    /**
     * The next page for the given response. Resolves to null if the page could
     * not be found.
     *
     * ```js
     * amadeus.referenceData.locations.get({
     *   keyword: 'LON',
     *   subType: 'AIRPORT,CITY'
     * }).then(function(response){
     *   console.log(response);
     *   return amadeus.next(response);
     * }).then(function(nextPage){
     *   console.log(nextPage);
     * });
     * ```
     *
     * @param response the previous response for an API call
     * @return {Promise.<Response,ResponseError>} a Bluebird Promise
     */

  }, {
    key: 'next',
    value: function next(response) {
      return this.pagination.page('next', response);
    }

    /**
     * The first page for the given response. Resolves to null if the page
     * could not be found.
     *
     * ```js
     * amadeus.referenceData.locations.get({
     *   keyword: 'LON',
     *   subType: 'AIRPORT,CITY',
     *   page: { offset: 2 }
     * }).then(function(response){
     *   console.log(response);
     *   return amadeus.first(response);
     * }).then(function(firstPage){
     *   console.log(firstPage);
     * });
     * ```
     *
     * @param response the previous response for an API call
     * @return {Promise.<Response,ResponseError>} a Bluebird Promise
     */

  }, {
    key: 'first',
    value: function first(response) {
      return this.pagination.page('first', response);
    }

    /**
     * The last page for the given response. Resolves to null if the page
     * could not be found.
     *
     * ```js
     * amadeus.referenceData.locations.get({
     *   keyword: 'LON',
     *   subType: 'AIRPORT,CITY'
     * }).then(function(response){
     *   console.log(response);
     *   return amadeus.last(response);
     * }).then(function(lastPage){
     *   console.log(lastPage);
     * });
     * ```
     *
     * @param response the previous response for an API call
     * @return {Promise.<Response,ResponseError>} a Bluebird Promise
     */

  }, {
    key: 'last',
    value: function last(response) {
      return this.pagination.page('last', response);
    }
  }]);

  return Amadeus;
}();

/**
 * A handy list of location types, to be used in the locations API:
 *
 * ```js
 * amadeus.referenceData.location.get({
 *   keyword: 'lon',
 *   subType: Amadeus.location.any
 * });
 * ```
 *
 * Currently available are the types `.airport`, `.city`, and `.any`
 */


Amadeus.location = {
  airport: 'AIRPORT',
  city: 'CITY',
  any: 'AIRPORT,CITY'
};

/**
 * A handy list of direction types, to be used in the Flight Busiest Period API:
 *
 * ```js
 * amadeus.travel.analytics.airTraffic.busiestPeriod.get({
 *   cityCode: 'par',
 *   perdiod: 2015,
 *   direction: Amadeus.direction.arriving
 * });
 * ```
 *
 * Currently available are the types `.arriving` and `.departing`
 */

Amadeus.direction = {
  arriving: 'ARRIVING',
  departing: 'DEPARTING'
};

exports.default = Amadeus;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hbWFkZXVzLmpzIl0sIm5hbWVzIjpbIkFtYWRldXMiLCJwYXJhbXMiLCJjbGllbnQiLCJDbGllbnQiLCJ2ZXJzaW9uIiwicmVmZXJlbmNlRGF0YSIsIlJlZmVyZW5jZURhdGEiLCJzaG9wcGluZyIsIlNob3BwaW5nIiwidHJhdmVsIiwiVHJhdmVsIiwicGFnaW5hdGlvbiIsIlBhZ2luYXRpb24iLCJyZXNwb25zZSIsInBhZ2UiLCJsb2NhdGlvbiIsImFpcnBvcnQiLCJjaXR5IiwiYW55IiwiZGlyZWN0aW9uIiwiYXJyaXZpbmciLCJkZXBhcnRpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNkNNQSxPO0FBQ0oscUJBQXlCO0FBQUEsUUFBYkMsTUFBYSx1RUFBSixFQUFJOztBQUFBOztBQUN2QixTQUFLQyxNQUFMLEdBQWMsSUFBSUMsZ0JBQUosQ0FBV0YsTUFBWCxDQUFkO0FBQ0EsU0FBS0csT0FBTCxHQUFlLEtBQUtGLE1BQUwsQ0FBWUUsT0FBM0I7O0FBRUEsU0FBS0MsYUFBTCxHQUFzQixJQUFJQyx3QkFBSixDQUFrQixLQUFLSixNQUF2QixDQUF0QjtBQUNBLFNBQUtLLFFBQUwsR0FBc0IsSUFBSUMsa0JBQUosQ0FBYSxLQUFLTixNQUFsQixDQUF0QjtBQUNBLFNBQUtPLE1BQUwsR0FBc0IsSUFBSUMsZ0JBQUosQ0FBVyxLQUFLUixNQUFoQixDQUF0QjtBQUNBLFNBQUtTLFVBQUwsR0FBa0IsSUFBSUMsb0JBQUosQ0FBZSxLQUFLVixNQUFwQixDQUFsQjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBb0JTVyxRLEVBQVU7QUFBRSxhQUFPLEtBQUtGLFVBQUwsQ0FBZ0JHLElBQWhCLENBQXFCLFVBQXJCLEVBQWlDRCxRQUFqQyxDQUFQO0FBQW9EOztBQUV6RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFtQktBLFEsRUFBYztBQUFFLGFBQU8sS0FBS0YsVUFBTCxDQUFnQkcsSUFBaEIsQ0FBcUIsTUFBckIsRUFBNkJELFFBQTdCLENBQVA7QUFBZ0Q7O0FBRXJFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFvQk1BLFEsRUFBYTtBQUFFLGFBQU8sS0FBS0YsVUFBTCxDQUFnQkcsSUFBaEIsQ0FBcUIsT0FBckIsRUFBOEJELFFBQTlCLENBQVA7QUFBaUQ7O0FBRXRFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQW1CS0EsUSxFQUFjO0FBQUUsYUFBTyxLQUFLRixVQUFMLENBQWdCRyxJQUFoQixDQUFxQixNQUFyQixFQUE2QkQsUUFBN0IsQ0FBUDtBQUFnRDs7Ozs7O0FBSXZFOzs7Ozs7Ozs7Ozs7OztBQVlBYixRQUFRZSxRQUFSLEdBQW1CO0FBQ2pCQyxXQUFTLFNBRFE7QUFFakJDLFFBQU0sTUFGVztBQUdqQkMsT0FBSztBQUhZLENBQW5COztBQU1BOzs7Ozs7Ozs7Ozs7OztBQWNBbEIsUUFBUW1CLFNBQVIsR0FBb0I7QUFDbEJDLFlBQVUsVUFEUTtBQUVsQkMsYUFBVztBQUZPLENBQXBCOztrQkFLZXJCLE8iLCJmaWxlIjoiYW1hZGV1cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDbGllbnQgICAgICAgIGZyb20gJy4vYW1hZGV1cy9jbGllbnQnO1xuaW1wb3J0IFBhZ2luYXRpb24gICAgZnJvbSAnLi9hbWFkZXVzL2NsaWVudC9wYWdpbmF0aW9uJztcblxuaW1wb3J0IFJlZmVyZW5jZURhdGEgZnJvbSAnLi9hbWFkZXVzL25hbWVzcGFjZXMvcmVmZXJlbmNlX2RhdGEnO1xuaW1wb3J0IFNob3BwaW5nICAgICAgZnJvbSAnLi9hbWFkZXVzL25hbWVzcGFjZXMvc2hvcHBpbmcnO1xuaW1wb3J0IFRyYXZlbCAgICAgICAgZnJvbSAnLi9hbWFkZXVzL25hbWVzcGFjZXMvdHJhdmVsJztcblxuLyoqXG4gKiBUaGUgQW1hZGV1cyBjbGllbnQgbGlicmFyeSBmb3IgYWNjZXNzaW5nIHRoZSB0cmF2ZWwgQVBJcy5cbiAqXG4gKiBJbml0aWFsaXplIHVzaW5nIHlvdXIgY3JlZGVudGlhbHM6XG4gKlxuICogYGBganNcbiAqIHZhciBBbWFkZXVzID0gcmVxdWlyZSgnYW1hZGV1cycpO1xuICogdmFyIGFtYWRldXMgPSBuZXcgQW1hZGV1cyh7XG4gKiAgICAgY2xpZW50SWQ6ICAgICdZT1VSX0NMSUVOVF9JRCcsXG4gKiAgICAgY2xpZW50U2VjcmV0OiAnWU9VUl9DTElFTlRfU0VDUkVUJ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCBpbml0aWFsaXplIHRoZSBsaWJyYXJ5IHVzaW5nXG4gKiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGBBTUFERVVTX0NMSUVOVF9JRGBcbiAqIGFuZCBgQU1BREVVU19DTElFTlRfU0VDUkVUYFxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYW1hZGV1cyA9IG5ldyBBbWFkZXVzKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNsaWVudElkIHRoZSBBUEkga2V5IHVzZWQgdG8gYXV0aGVudGljYXRlIHRoZSBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2xpZW50U2VjcmV0IHRoZSBBUEkgc2VjcmV0IHVzZWQgdG8gYXV0aGVudGljYXRlXG4gKiAgdGhlIEFQSVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMubG9nZ2VyPWNvbnNvbGVdIGEgYGNvbnNvbGVgLWNvbXBhdGlibGUgbG9nZ2VyIHRoYXRcbiAqICBhY2NlcHRzIGBsb2dgLCBgZXJyb3JgIGFuZCBgZGVidWdgIGNhbGxzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubG9nTGV2ZWw9J3dhcm4nXSB0aGUgbG9nIGxldmVsIGZvciB0aGUgY2xpZW50LFxuICogIGF2YWlsYWJsZSBvcHRpb25zIGFyZSBgZGVidWdgLCBgd2FybmAsIGFuZCBgc2lsZW50YFxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuaG9zdG5hbWU9J3Byb2R1Y3Rpb24nXSB0aGUgbmFtZSBvZiB0aGUgc2VydmVyIEFQSVxuICogIGNhbGxzIGFyZSBtYWRlIHRvIChgcHJvZHVjdGlvbmAgb3IgYHRlc3RgKVxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuaG9zdF0gdGhlIGZ1bGwgZG9tYWluIG9yIElQIGZvciBhIHNlcnZlciB0byBtYWtlIHRoZVxuICogIEFQSSBjbGFsIHRvLiBPbmx5IHVzZSB0aGlzIGlmIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgcHJvdmlkZWQgc2VydmVyc1xuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNzbD10cnVlXSB3ZXRoZXIgdG8gdXNlIFNTTCBmb3IgdGhpcyBBUEkgY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMucG9ydD00NDNdIHRoZSBwb3J0IHRvIG1ha2UgdGhlIEFQSSBjYWxsIHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5jdXN0b21BcHBJZD1udWxsXSBhIGN1c3RvbSBBcHAgSUQgdG8gYmUgcGFzc2VkIGluXG4gKiB0aGUgVXNlciBBZ2VudCB0byB0aGUgc2VydmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY3VzdG9tQXBwVmVyc2lvbj1udWxsXSBhIGN1c3RvbSBBcHAgVmVyc2lvbiBudW1iZXIgdG9cbiAqIGJlIHBhc3NlZCBpbiB0aGUgVXNlciBBZ2VudCB0byB0aGUgc2VydmVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMuaHR0cD1odHRwc10gYW4gb3B0aW9uYWwgTm9kZS9IVFRQKFMpLWNvbXBhdGlibGUgY2xpZW50XG4gKiAgdGhhdCBhY2NlcHRzIGEgJ3JlcXVlc3QoKScgY2FsbCB3aXRoIGFuIGFycmF5IG9mIG9wdGlvbnMuXG4gKlxuICogQHByb3BlcnR5IHtDbGllbnR9IGNsaWVudCBUaGUgY2xpZW50IGZvciBtYWtpbmcgYXV0aGVudGljYXRlZCBIVFRQIGNhbGxzXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbiBUaGUgdmVyc2lvbiBvZiB0aGlzIEFQSSBjbGllbnRcbiAqL1xuY2xhc3MgQW1hZGV1cyB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgQ2xpZW50KHBhcmFtcyk7XG4gICAgdGhpcy52ZXJzaW9uID0gdGhpcy5jbGllbnQudmVyc2lvbjtcblxuICAgIHRoaXMucmVmZXJlbmNlRGF0YSAgPSBuZXcgUmVmZXJlbmNlRGF0YSh0aGlzLmNsaWVudCk7XG4gICAgdGhpcy5zaG9wcGluZyAgICAgICA9IG5ldyBTaG9wcGluZyh0aGlzLmNsaWVudCk7XG4gICAgdGhpcy50cmF2ZWwgICAgICAgICA9IG5ldyBUcmF2ZWwodGhpcy5jbGllbnQpO1xuICAgIHRoaXMucGFnaW5hdGlvbiA9IG5ldyBQYWdpbmF0aW9uKHRoaXMuY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgcGFnZSBmb3IgdGhlIGdpdmVuIHJlc3BvbnNlLiBSZXNvbHZlcyB0byBudWxsIGlmIHRoZSBwYWdlXG4gICAqIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAgICpcbiAgICogYGBganNcbiAgICogYW1hZGV1cy5yZWZlcmVuY2VEYXRhLmxvY2F0aW9ucy5nZXQoe1xuICAgKiAgIGtleXdvcmQ6ICdMT04nLFxuICAgKiAgIHN1YlR5cGU6ICdBSVJQT1JULENJVFknLFxuICAgKiAgIHBhZ2U6IHsgb2Zmc2V0OiAyIH1cbiAgICogfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAqICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgKiAgIHJldHVybiBhbWFkZXVzLnByZXZpb3VzKHJlc3BvbnNlKTtcbiAgICogfSkudGhlbihmdW5jdGlvbihwcmV2aW91c1BhZ2Upe1xuICAgKiAgIGNvbnNvbGUubG9nKHByZXZpb3VzUGFnZSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHRoZSBwcmV2aW91cyByZXNwb25zZSBmb3IgYW4gQVBJIGNhbGxcbiAgICogQHJldHVybiB7UHJvbWlzZS48UmVzcG9uc2UsUmVzcG9uc2VFcnJvcj59IGEgQmx1ZWJpcmQgUHJvbWlzZVxuICAgKi9cbiAgcHJldmlvdXMocmVzcG9uc2UpIHsgcmV0dXJuIHRoaXMucGFnaW5hdGlvbi5wYWdlKCdwcmV2aW91cycsIHJlc3BvbnNlKTsgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmV4dCBwYWdlIGZvciB0aGUgZ2l2ZW4gcmVzcG9uc2UuIFJlc29sdmVzIHRvIG51bGwgaWYgdGhlIHBhZ2UgY291bGRcbiAgICogbm90IGJlIGZvdW5kLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhbWFkZXVzLnJlZmVyZW5jZURhdGEubG9jYXRpb25zLmdldCh7XG4gICAqICAga2V5d29yZDogJ0xPTicsXG4gICAqICAgc3ViVHlwZTogJ0FJUlBPUlQsQ0lUWSdcbiAgICogfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAqICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgKiAgIHJldHVybiBhbWFkZXVzLm5leHQocmVzcG9uc2UpO1xuICAgKiB9KS50aGVuKGZ1bmN0aW9uKG5leHRQYWdlKXtcbiAgICogICBjb25zb2xlLmxvZyhuZXh0UGFnZSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHRoZSBwcmV2aW91cyByZXNwb25zZSBmb3IgYW4gQVBJIGNhbGxcbiAgICogQHJldHVybiB7UHJvbWlzZS48UmVzcG9uc2UsUmVzcG9uc2VFcnJvcj59IGEgQmx1ZWJpcmQgUHJvbWlzZVxuICAgKi9cbiAgbmV4dChyZXNwb25zZSkgICAgIHsgcmV0dXJuIHRoaXMucGFnaW5hdGlvbi5wYWdlKCduZXh0JywgcmVzcG9uc2UpOyB9XG5cbiAgLyoqXG4gICAqIFRoZSBmaXJzdCBwYWdlIGZvciB0aGUgZ2l2ZW4gcmVzcG9uc2UuIFJlc29sdmVzIHRvIG51bGwgaWYgdGhlIHBhZ2VcbiAgICogY291bGQgbm90IGJlIGZvdW5kLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhbWFkZXVzLnJlZmVyZW5jZURhdGEubG9jYXRpb25zLmdldCh7XG4gICAqICAga2V5d29yZDogJ0xPTicsXG4gICAqICAgc3ViVHlwZTogJ0FJUlBPUlQsQ0lUWScsXG4gICAqICAgcGFnZTogeyBvZmZzZXQ6IDIgfVxuICAgKiB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICogICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAqICAgcmV0dXJuIGFtYWRldXMuZmlyc3QocmVzcG9uc2UpO1xuICAgKiB9KS50aGVuKGZ1bmN0aW9uKGZpcnN0UGFnZSl7XG4gICAqICAgY29uc29sZS5sb2coZmlyc3RQYWdlKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgdGhlIHByZXZpb3VzIHJlc3BvbnNlIGZvciBhbiBBUEkgY2FsbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxSZXNwb25zZSxSZXNwb25zZUVycm9yPn0gYSBCbHVlYmlyZCBQcm9taXNlXG4gICAqL1xuICBmaXJzdChyZXNwb25zZSkgICAgeyByZXR1cm4gdGhpcy5wYWdpbmF0aW9uLnBhZ2UoJ2ZpcnN0JywgcmVzcG9uc2UpOyB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IHBhZ2UgZm9yIHRoZSBnaXZlbiByZXNwb25zZS4gUmVzb2x2ZXMgdG8gbnVsbCBpZiB0aGUgcGFnZVxuICAgKiBjb3VsZCBub3QgYmUgZm91bmQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFtYWRldXMucmVmZXJlbmNlRGF0YS5sb2NhdGlvbnMuZ2V0KHtcbiAgICogICBrZXl3b3JkOiAnTE9OJyxcbiAgICogICBzdWJUeXBlOiAnQUlSUE9SVCxDSVRZJ1xuICAgKiB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICogICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAqICAgcmV0dXJuIGFtYWRldXMubGFzdChyZXNwb25zZSk7XG4gICAqIH0pLnRoZW4oZnVuY3Rpb24obGFzdFBhZ2Upe1xuICAgKiAgIGNvbnNvbGUubG9nKGxhc3RQYWdlKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgdGhlIHByZXZpb3VzIHJlc3BvbnNlIGZvciBhbiBBUEkgY2FsbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxSZXNwb25zZSxSZXNwb25zZUVycm9yPn0gYSBCbHVlYmlyZCBQcm9taXNlXG4gICAqL1xuICBsYXN0KHJlc3BvbnNlKSAgICAgeyByZXR1cm4gdGhpcy5wYWdpbmF0aW9uLnBhZ2UoJ2xhc3QnLCByZXNwb25zZSk7IH1cbn1cblxuXG4vKipcbiAqIEEgaGFuZHkgbGlzdCBvZiBsb2NhdGlvbiB0eXBlcywgdG8gYmUgdXNlZCBpbiB0aGUgbG9jYXRpb25zIEFQSTpcbiAqXG4gKiBgYGBqc1xuICogYW1hZGV1cy5yZWZlcmVuY2VEYXRhLmxvY2F0aW9uLmdldCh7XG4gKiAgIGtleXdvcmQ6ICdsb24nLFxuICogICBzdWJUeXBlOiBBbWFkZXVzLmxvY2F0aW9uLmFueVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBDdXJyZW50bHkgYXZhaWxhYmxlIGFyZSB0aGUgdHlwZXMgYC5haXJwb3J0YCwgYC5jaXR5YCwgYW5kIGAuYW55YFxuICovXG5BbWFkZXVzLmxvY2F0aW9uID0ge1xuICBhaXJwb3J0OiAnQUlSUE9SVCcsXG4gIGNpdHk6ICdDSVRZJyxcbiAgYW55OiAnQUlSUE9SVCxDSVRZJ1xufTtcblxuLyoqXG4gKiBBIGhhbmR5IGxpc3Qgb2YgZGlyZWN0aW9uIHR5cGVzLCB0byBiZSB1c2VkIGluIHRoZSBGbGlnaHQgQnVzaWVzdCBQZXJpb2QgQVBJOlxuICpcbiAqIGBgYGpzXG4gKiBhbWFkZXVzLnRyYXZlbC5hbmFseXRpY3MuYWlyVHJhZmZpYy5idXNpZXN0UGVyaW9kLmdldCh7XG4gKiAgIGNpdHlDb2RlOiAncGFyJyxcbiAqICAgcGVyZGlvZDogMjAxNSxcbiAqICAgZGlyZWN0aW9uOiBBbWFkZXVzLmRpcmVjdGlvbi5hcnJpdmluZ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBDdXJyZW50bHkgYXZhaWxhYmxlIGFyZSB0aGUgdHlwZXMgYC5hcnJpdmluZ2AgYW5kIGAuZGVwYXJ0aW5nYFxuICovXG5cbkFtYWRldXMuZGlyZWN0aW9uID0ge1xuICBhcnJpdmluZzogJ0FSUklWSU5HJyxcbiAgZGVwYXJ0aW5nOiAnREVQQVJUSU5HJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQW1hZGV1cztcbiJdfQ==